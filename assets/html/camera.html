<!DOCTYPE html>
<html>

<head>
  <script async src="https://unpkg.com/es-module-shims@1.7.2/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/",
        "mindar-face-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-face-three.prod.js",
        "gltfloader": "./scripts/GLTFLoader.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { MindARThree } from 'mindar-face-three';
    import { GLTFLoader } from './scripts/GLTFLoader.js';

    const mindarThree = new MindARThree({
      container: document.querySelector("#container"),
    });


    const { renderer, scene, camera } = mindarThree;

    const threeCanvas = renderer.domElement;
    const canvasStream = threeCanvas.captureStream(60); // 60 FPS

    const loader = new GLTFLoader();

    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const light = new THREE.HemisphereLight(skyColor, groundColor, 1);
    scene.add(light);

    let mustacheAnchor;

    function cambiarFiltro(url, anchor) {
      if (mustacheAnchor) {
        scene.remove(mustacheAnchor.group);
        mustacheAnchor = null;
      }

      mustacheAnchor = mindarThree.addAnchor(anchor);
      loader.load(
        url,
        function (gltf) {
          mustacheAnchor.group.add(gltf.scene);
        },
        function (xhr) {
          // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },
        function (error) {
          // console.log('An error happened');
        }
      );
    }

    const start = async () => {
      await mindarThree.start();
      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });
    }

    start();

    let mediaRecorder;
    let recordedChunks = [];


    async function getCombinedStream() {
      try {
        // Captura tanto el vídeo como el audio
        const mediaStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720 }, // Resolución con aspect ratio 9:16
          video: true, audio: true
        });

        const videoElement = document.createElement('video');
        videoElement.srcObject = mediaStream;
        videoElement.muted = true;
        videoElement.style.position = 'absolute';
        videoElement.style.width = '100%';
        videoElement.style.height = '100%';
        videoElement.style.objectFit = 'cover';
        videoElement.play();


        const compositeCanvas = document.getElementById('compositeCanvas');
        compositeCanvas.style.display = 'block';
        compositeCanvas.style.position = 'absolute';
        compositeCanvas.style.width = '100%';
        compositeCanvas.style.height = '100%';
        compositeCanvas.style.objectFit = 'cover';
        const context = compositeCanvas.getContext('2d');

        const draw = () => {
          if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
            context.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            context.drawImage(videoElement, 0, 0, compositeCanvas.width, compositeCanvas.height);
            context.drawImage(threeCanvas, 0, 0, compositeCanvas.width, compositeCanvas.height);

          }
          requestAnimationFrame(draw);
        };

        draw();

        // Captura el stream del canvas compuesto y agrega las pistas de audio del mediaStream
        const combinedStream = new MediaStream([...compositeCanvas.captureStream(60).getVideoTracks(), ...mediaStream.getAudioTracks()]);
        return combinedStream;

      } catch (error) {
        console.error('Error accessing media devices.', error);
        return null;
      }
    }




    async function getVideoStream() {
      try {
        // Captura solo el vídeo, sin audio, para evitar el rebote
        const videoStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720 }, // HD resolution
          video: true, audio: false
        });
        return videoStream;
      } catch (error) {
        console.error('Error accessing media devices.', error);
        return null;
      }
    }

    async function getAudioStream() {
      try {
        // Captura solo el audio
        const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        return audioStream;
      } catch (error) {
        console.error('Error accessing media devices.', error);
        return null;
      }
    }


    function startRecording(stream, id) {
      recordedChunks = [];

      // Inicializa el MediaRecorder con el stream del canvas de composición
      mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'video/webm',
        videoBitsPerSecond: 5000000 // Aumentar la tasa de bits
      });

      mediaRecorder.ondataavailable = function (event) {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = () => onRecordingStopped(id);
      mediaRecorder.start();
    }

  
    var combinedStream;

    window.addEventListener('message', async (event) => {
      const data = event.data;
     
      // Take Picture
      if (data.action === 'startScreenshoot') {
          takeScreenshot(data.id);
      }
      // Start Recording
      else if (data && data.action === 'startRecording') {
        combinedStream = await getCombinedStream(); // Obtiene el stream combinado
        if (combinedStream) {
          startRecording(combinedStream, data.id);
        }
      } 
      // Stop Recording
      else if (data && data.action === 'stopRecording') {
        if (combinedStream) {
          if (mediaRecorder && mediaRecorder.state === "recording") {
              mediaRecorder.stop();
            }
        }
      } 
      // Change Filter
      else if (data && data.url && data.anchor) {
        cambiarFiltro(data.url, data.anchor);
      }
    }, false);

    // Function that send the screenshot to flutter
    async function takeScreenshot(id) {
      const videoElement = document.querySelector('video'); // Asegúrate de que esto selecciona el elemento de video correcto
      if (videoElement) {
          const canvas = document.createElement('canvas');
          canvas.width = videoElement.videoWidth;
          canvas.height = videoElement.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
          const screenshotData = canvas.toDataURL('image/png');

          // console.log("Captura de pantalla tomada:", screenshotData); // Log para verificar los datos

          window.parent.postMessage({
              "iframeId": id,
              "action": "picture",
              "screenshotData": screenshotData,
          }, '*');
      }
    }
    
    // Function that send the recorded video to flutter
    function onRecordingStopped(id) {
      const blob = new Blob(recordedChunks, { type: "video/webm" });
      const url = window.URL.createObjectURL(blob);
      const reader = new FileReader();

      reader.onloadend = () => {
        const base64data = reader.result;
        //console.log("Vídeo frontal desde nativo grabado:", base64data); // Log para verificar los datos

        // Enviar mensaje a la cámara trasera
        window.parent.postMessage({
          "iframeId": id,
          "action": "video",
          "videoBase64": base64data
        }, '*');


      };
      reader.readAsDataURL(blob);

     /*  // Crear un enlace para la descarga del vídeo
      const a = document.createElement("a");
      document.body.appendChild(a);
      a.style = "display: none";
      a.href = url;
      a.download = "recordedVideo.webm"; // Nombre del archivo
      a.click(); */

      // Liberar recursos
      window.URL.revokeObjectURL(url);
      a.remove();
    }


  </script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      /* Evita desbordamientos */

    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }

    #control {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 2;
    }

    #videoElement,
    #compositeCanvas {
      width: 100%;
      /* Ajusta al ancho del contenedor */
      width: 100%;
      height: 100%;
      /* Define la relación de aspecto deseada */
      object-fit: cover;
      /* Asegura que el video y el canvas cubran todo el contenedor */
      z-index: 1;

      /* Pone el canvas sobre el video */
      #videoElement {
        z-index: 0;
        /* Pone el video detrás del canvas */
      }
    }
  </style>
</head>

<body>
  <div id="container" style="width: 100vw; /* O un ancho específico */">
    <!-- Tus elementos de video y canvas aquí -->
  </div>
  </div>
  <canvas id="compositeCanvas" width="1280" height="720" style="display: none;"></canvas>
</body>

</html>